<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>428</string>
	<key>AMApplicationVersion</key>
	<string>2.7</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0.2</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>on run {input, parameters}tell me to activate	return inputend run</string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0.2</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>InputUUID</key>
				<string>3D56558E-8952-48CB-BFEF-37B7918CF190</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>6696F47E-4544-4ACB-A06A-E9D4813E3CEF</string>
				<key>UUID</key>
				<string>1C410E4D-55FD-4C3A-9DED-99126C8F2CC7</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>conversionLabel</key>
				<integer>0</integer>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>449.000000:112.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.path</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.2.1</string>
				<key>AMApplication</key>
				<array>
					<string>Finder</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>defaultLocation</key>
					<dict>
						<key>isPathPopUp</key>
						<true/>
						<key>variableUUIDsInMenu</key>
						<array/>
					</dict>
					<key>granularity</key>
					<dict/>
					<key>multipleSelection</key>
					<dict/>
					<key>promptMessage</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.path</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Ask for Finder Items.action</string>
				<key>ActionName</key>
				<string>Ask for Finder Items</string>
				<key>ActionParameters</key>
				<dict>
					<key>defaultLocation</key>
					<string>~/Desktop</string>
					<key>granularity</key>
					<integer>1</integer>
					<key>multipleSelection</key>
					<false/>
					<key>promptMessage</key>
					<string>Choose a Finder Item:</string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.AskForFinderItems</string>
				<key>CFBundleVersion</key>
				<string>1.2.1</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<true/>
				<key>CanShowWhenRun</key>
				<false/>
				<key>Category</key>
				<array>
					<string>AMCategoryFilesAndFolders</string>
				</array>
				<key>Class Name</key>
				<string>AMAskForFinderItemsAction</string>
				<key>InputUUID</key>
				<string>FF5B234C-CF86-42B6-93BB-7D920A7C3267</string>
				<key>Keywords</key>
				<array>
					<string>Find</string>
					<string>Item</string>
					<string>File</string>
					<string>Folder</string>
					<string>Ask</string>
					<string>Choose</string>
					<string>Prompt</string>
				</array>
				<key>OutputUUID</key>
				<string>681F1477-7620-443E-8789-8F0BAA24714D</string>
				<key>UUID</key>
				<string>1D5440C0-F1CA-47CE-B667-C9E85856710F</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Finder</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>multipleSelection</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>granularity</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<string>~/Desktop</string>
						<key>name</key>
						<string>defaultLocation</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string>Choose a Finder Item:</string>
						<key>name</key>
						<string>promptMessage</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
				</dict>
				<key>conversionLabel</key>
				<integer>0</integer>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>449.000000:154.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Ask for Finder Items.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.3</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict/>
					<key>CheckedForUserDefaultShell</key>
					<dict/>
					<key>inputMethod</key>
					<dict/>
					<key>shell</key>
					<dict/>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>cd "$1"
rm -r /tmp/DUALISO
mkdir -p /tmp/DUALISO
echo "$1" &gt; /tmp/DUALISO/path_1
#set First_out.app path
echo "$1" &gt; /tmp/path_1b
</string>
					<key>CheckedForUserDefaultShell</key>
					<true/>
					<key>inputMethod</key>
					<integer>1</integer>
					<key>shell</key>
					<string>/bin/bash</string>
					<key>source</key>
					<string></string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.3</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>InputUUID</key>
				<string>D419118B-B246-45EF-A9AB-A5DB43675084</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>F2A3EDC1-7B88-4A84-A9D7-AC71E1167E58</string>
				<key>UUID</key>
				<string>C9EE4BBE-A1FF-4172-A973-407B448054A0</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>conversionLabel</key>
				<integer>0</integer>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>449.000000:196.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0.2</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>on run {input, parameters}   set p to POSIX path of (path to me)   return {p}end run</string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0.2</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>InputUUID</key>
				<string>7C24AD1A-887B-4252-BD1B-8E84AAB1FF18</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>BB45ABEF-0FC5-4C66-8242-0FBB8E521D06</string>
				<key>UUID</key>
				<string>38172F58-AC15-47C5-B12F-FD2A20EE20D6</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>conversionLabel</key>
				<integer>0</integer>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>449.000000:238.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/Base.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.3</string>
				<key>AMApplication</key>
				<array>
					<string>Automator</string>
				</array>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict/>
					<key>CheckedForUserDefaultShell</key>
					<dict/>
					<key>inputMethod</key>
					<dict/>
					<key>shell</key>
					<dict/>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>#GNU public license
#This program is free software; you can redistribute it and/or
 # modify it under the terms of the GNU General Public License
 # as published by the Free Software Foundation; either version 2
 # of the License, or (at your option) any later version.
 # 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
 # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 # GNU General Public License for more details.
 # 
 # You should have received a copy of the GNU General Public License
 # along with this program; if not, write to the
 # Free Software Foundation, Inc.,
 # 51 Franklin Street, Fifth Floor,
 # Boston, MA  02110-1301, USA.

#Processing order(if files included in root folder)
#HDR_PROCESSING
#Export to ProRes4444 and/or ProRes proxy(MOV, mts etc, includes HDR mov) 
#Manually selected FLATFRAMES processing
#Fully automated flatframe processing
#Automated darkframe processing
#extra round to check if darkframe or flatframe still are present in root folder
#Create darkframe MLV files from storage folder
#Processing of MLV files
#cr2hdr processing(MLV files)
#Processing of RAW files
#cr2hdr processing(RAW files)
#Export to ProRes4444 and/or ProRes proxy
#run cr2hdr 4 processes in parallel(CR2,DNG,dng files)

#Main code. For it to take effect it has to be copied into Switch. Do so by opening Switch in automator.
#First output path
    echo "$1" | perl -pi -e 's/Contents\/First_out.app\///g' 2&gt;/dev/null | perl -p -e 's/^[ \t]*//' &gt; /tmp/DUALISO/path_2
    cd "$(cat /tmp/DUALISO/path_1)"
    path_2=$(cat /tmp/DUALISO/path_2)
#Main menu command, afplayer
    find "$path_2"Contents/Menu.command -exec xattr -d -r com.apple.quarantine {} \;
    find "$path_2"Contents/afplayer.command -exec xattr -d -r com.apple.quarantine {} \;
    find "$path_2"Contents/progress_bar.command -exec xattr -d -r com.apple.quarantine {} \;
    find "$path_2"Contents/Switch_MAIN_DBG.command -exec xattr -d -r com.apple.quarantine {} \;
    export PATH="$path_2"Contents:$PATH
    cd "$(cat /tmp/DUALISO/path_1)"
    rm "$(cat /tmp/DUALISO/path_1)"/LOG.txt
    exec &amp;&gt; &gt;(tee -a "$(cat /tmp/DUALISO/path_1)"/LOG.txt &gt;&amp;2 )
#build Folder structure
    mkdir -p A_ORIGINALS
    mkdir -p /tmp/DUALISO/
#if RAW ask for MLV conversion
#courtesy bouncyball at magiclantern.fm
    if grep 'RAW' &lt;&lt;&lt; $(ls *.RAW | head -1 | grep -o '[^/]*$')
    then
#create app path
    echo "$path_2"Contents/ &gt; /tmp/DUALISO/path_2
    ls *.RAW &gt; /tmp/DUALISO/list_RAW
    echo &gt; /tmp/DUALISO/RAW_demolish
    open "$path_2"Contents/Menu.command &amp; sleep 1
    while ls /tmp/DUALISO/RAW_demolish 
    do sleep 1
    done
    if ! ls /tmp/DUALISO/RAW
    then
    exit 0
    fi
    if grep '01_legacy_RAW_to_MLV' /tmp/DUALISO/RAW
    then 
#if chosen alternate location
    if [ -f /tmp/DUALISO/RAW_OUTPUT ]
    then
    mkdir -p "$(cat /tmp/DUALISO/RAW_OUTPUT | awk 'FNR == 1 {print; }')"
    ln -s "$(cat /tmp/DUALISO/path_1)"/*.R* "$(cat /tmp/DUALISO/RAW_OUTPUT | awk 'FNR == 1 {print; }')"
    cd "$(cat /tmp/DUALISO/RAW_OUTPUT | awk 'FNR == 1 {print; }')" 
    ls *.RAW &gt; /tmp/DUALISO/list_RAW_02
    while grep 'RAW' /tmp/DUALISO/list_RAW_02
    do
    raw2dng "$(cat /tmp/DUALISO/list_RAW_02 | awk 'FNR == 1 {print; }')" --mlv
    mv -i "$(cat /tmp/DUALISO/path_1)"/"$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }')" "$(cat /tmp/DUALISO/path_1)"/A_ORIGINALS
    if [ -f "$(cat /tmp/DUALISO/path_1)"/"$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }' | cut -d "." -f1)".R00 ]
    then
    mv -i "$(cat /tmp/DUALISO/path_1)"/"$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }' | cut -d "." -f1)".R* "$(cat /tmp/DUALISO/path_1)"/A_ORIGINALS
    fi
    echo "$(tail -n +2 /tmp/DUALISO/list_RAW)" &gt; /tmp/DUALISO/list_RAW
    echo "$(tail -n +2 /tmp/DUALISO/list_RAW_02)" &gt; /tmp/DUALISO/list_RAW_02
    done
    cd "$(cat /tmp/DUALISO/RAW_OUTPUT | awk 'FNR == 1 {print; }')"
    find . -type l -exec rm {} \;
    rm /tmp/DUALISO/list_RAW
    rm /tmp/DUALISO/list_RAW_02
    cd ..
    exit 0
    fi
    while grep 'RAW' /tmp/DUALISO/list_RAW
    do
    raw2dng "$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }')" --mlv 
    mv -i "$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }')" A_ORIGINALS
    if [ -f "$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }' | cut -d "." -f1)".R00 ]
    then
    mv -i "$(cat /tmp/DUALISO/list_RAW | awk 'FNR == 1 {print; }' | cut -d "." -f1)".R* A_ORIGINALS
    fi
    echo "$(tail -n +2 /tmp/DUALISO/list_RAW)" &gt; /tmp/DUALISO/list_RAW
    done
    exit 0
    fi
    fi
#if RAW check for pixel fix continue adding script during RAW processing later on
    file=$(ls *.RAW | head -1)
    raw2dng $file /tmp/DUALISO/what_cam_ | awk '/FPS/ { print $3; exit }' &gt; /tmp/DUALISO/fpss
    exiftool /tmp/DUALISO/what_cam_000000.dng | awk '/Image Size/ { print $4; }' &gt; /tmp/DUALISO/image_size
    exiftool /tmp/DUALISO/what_cam_000000.dng | awk '/Camera Model Name/ { print $5; }' &gt; /tmp/DUALISO/MOD
    exiftool /tmp/DUALISO/what_cam_000000.dng -X &gt; /tmp/DUALISO/what_cam.txt -overwrite_original
    rm /tmp/DUALISO/what_cam_000000.dng
    if grep 'ColorMatrix1&gt;0.6602' /tmp/DUALISO/what_cam.txt
    then 
    echo &gt; /tmp/DUALISO/what_cam_lock
    open "$path_2"Contents/Menu.command
    fi
    while ls /tmp/DUALISO/what_cam_lock
    do sleep 2
    done
#check if filmed crop_rec eosm 
    if grep 'M' &lt;&lt;&lt; $(mlv_dump -v -m "$(ls -A1 *.MLV *.mlv | head -1)" | awk '/Camera Name/ { print $5; exit}')
    then 
    echo &gt; /tmp/DUALISO/crop_rec? 
    fi
#check if filmed crop_rec 700D
    if grep '700D\|T5i\|X7i' &lt;&lt;&lt; $(mlv_dump -v -m "$(ls -A1 *.MLV *.mlv | head -1)" | awk '/Camera Name/ { print $4,$5,$6,$7; exit}')
    then 
    echo &gt; /tmp/DUALISO/crop_rec? 
    fi
#Call menu selector
    echo &gt; /tmp/DUALISO/DUALISO
    echo "$path_2"Contents/ &gt; /tmp/DUALISO/path_2
#in case of debug mode
    echo "$path_2" &gt; /tmp/DUALISO/DBG_path
    open "$path_2"Contents/Menu.command &amp; sleep 1
    while ls /tmp/DUALISO/DUALISO 2&gt;/dev/null
    do sleep 1
    done
    if [ -f /tmp/DUALISO/DUALISO_exit ]
    then 
    exit 0
    fi
#check for new output folder
    if [ -f /tmp/output ]
    then
    mkdir -p "$(cat /tmp/output)"
    O=$(cat /tmp/"output")/
    fi
#Total time command starts here
    res1=$(date +%s)
#if using the steroid version
    if [ -f /tmp/mlv_dump_on_steroids_settings ]
    then 
    mlv_dump=$(printf "%s\n" mlv_dump_on_steroids)
    else
    mlv_dump=$(printf "%s\n" mlv_dump)
    fi
###############################################################
#HDR_PROCESSING
    if [ -f /tmp/HDRCR2 ]
    then
    rm /tmp/DUALISO/CR2LIST
    rm /tmp/DUALISO/LIST
    ls *.CR2 &gt; /tmp/DUALISO/CR2LIST
#Start HDRCR2_grouping counter
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    if grep -q 'CR2' /tmp/DUALISO/CR2LIST
    then
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp; 
    fi
    fi
    echo -n $(cat /tmp/DUALISO/CR2LIST | awk 'FNR == 1') &gt;&gt; /tmp/DUALISO/LIST
    while grep 'CR2' /tmp/DUALISO/CR2LIST &gt;/dev/null 2&gt;&amp;1
    do
    num1=$(exiftool "$(cat /tmp/DUALISO/CR2LIST | awk 'FNR == 2')" | awk '/Modify Date/ { print $5; exit}' | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }') 
    num2=$(exiftool "$(cat /tmp/DUALISO/CR2LIST | awk 'FNR == 1')" | awk '/Modify Date/ { print $5; exit}' | awk -F: '{ print ($1 * 3600) + ($2 * 60) + $3 }')
    num=$(echo "$num1" - "$num2" | bc -l)
#group CR2 files accordingly
    if (( $(echo "$num &lt; 10" |bc -l) ))
    then
    echo -n " $(cat /tmp/DUALISO/CR2LIST | awk 'FNR == 2')" &gt;&gt; /tmp/DUALISO/LIST
    echo -n "$(tail -n +2 /tmp/DUALISO/CR2LIST)" &gt; /tmp/DUALISO/CR2LIST
    else
    echo "" &gt;&gt; /tmp/DUALISO/LIST
    echo -n "$(tail -n +2 /tmp/DUALISO/CR2LIST)" &gt; /tmp/DUALISO/CR2LIST
    echo -n $(cat /tmp/DUALISO/CR2LIST | awk 'FNR == 1') &gt;&gt; /tmp/DUALISO/LIST
    fi
    done
#HDRCR2 settings
    if [ -f /tmp/HDRCR2_settings ]
    then
    HDR="$(cat /tmp/"HDRCR2_settings" | perl -p -e 's/^[ \t]*//')"
    fi
#split into 4 chunks
    split -l $(( $( wc -l &lt; /tmp/DUALISO/LIST ) / 4 + 1 )) /tmp/DUALISO/LIST /tmp/DUALISO/LIST

#Start HDRCR2 counter
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    if grep -q 'CR2' /tmp/DUALISO/LISTaa 
    then
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp; 
    fi
    fi
    . "$path_2"Contents/HDR2.command &amp; pid2=$!
    . "$path_2"Contents/HDR3.command &amp; pid3=$!
    . "$path_2"Contents/HDR4.command &amp; pid4=$!
    while grep 'CR2' /tmp/DUALISO/LISTaa &gt;/dev/null 2&gt;&amp;1
    do 
#check for alternate output
if ! [ -d "$(cat /tmp/HDRCR2output)" ]
    then
    /Applications/HDRMerge.app/Contents/MacOS/hdrmerge $HDR -a $(cat /tmp/DUALISO/LISTaa | awk 'FNR == 1')
    mv $(cat /tmp/DUALISO/LISTaa | awk 'FNR == 1') A_ORIGINALS
    else
    /Applications/HDRMerge.app/Contents/MacOS/hdrmerge $HDR -o "$(cat /tmp/HDRCR2output)"/%iF[0]-%in[-1].dng $(cat /tmp/DUALISO/LISTaa | awk 'FNR == 1')
    fi
    echo "$(tail -n +2 /tmp/DUALISO/LISTaa)" &gt; /tmp/DUALISO/LISTaa
    done
#wait for jobs to end
    wait &lt; &lt;(jobs -p)
    rm /tmp/DUALISO/LISTaa
    rm /tmp/DUALISO/LIST
    fi
###############################################################
#Export to ProRes4444 and/or ProRes proxy 
#listing files(non raw)
    if ! [ x"$(cat /tmp/_X_Proxy)" = x ]
    then
    for f in *; do [[ -f "$f" ]] &amp;&amp; ls "$f" | grep -v 'RAW\|R00\|R01\|R02\|R03\|R04\|R05\|R06\|R07\|R08\|R09\|R10\|R11\|R12\|R13\|R14\|R15\|MLV\|M00\|M01\|M02\|M03\|M04\|M05\|M06\|M07\|M08\|M09\|\|M10\|M11\|M12\|M13\|M14\|M15\|CR2\|dng\|DNG\|txt\|TXT\|tif\|tiff\|TIF\|TIFF\|jpg\|JPG\|cube\|CUBE\|command' &gt;&gt; /tmp/DUALISO/FFmpeg_ALL; done 
    if ! [ x"$(cat /tmp/DUALISO/FFmpeg_ALL)" = x ]
    then
#Start X ProRes counter
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then 
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
#ProRes time command
    res15=$(date +%s)
sleep 1
    . "$path_2"Contents/FFmpeg_ALL_01.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_02.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_03.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_04.command &amp; sleep 1
    fi
    fi
#check for proxy
    if [ x"$(cat /tmp/_X_Proxy)" = x ]
    then
    if ! [ x"$(cat /tmp/_X_ProRes4444)" = x ]
    then
     for f in *; do [[ -f "$f" ]] &amp;&amp; ls "$f" | grep -v 'RAW\|R00\|R01\|R02\|R03\|R04\|R05\|R06\|R07\|R08\|R09\|R10\|R11\|R12\|R13\|R14\|R15\|MLV\|M00\|M01\|M02\|M03\|M04\|M05\|M06\|M07\|M08\|M09\|\|M10\|M11\|M12\|M13\|M14\|M15\|CR2\|dng\|DNG\|txt\|TXT\|tif\|tiff\|TIF\|TIFF\|jpg\|JPG\|cube\|CUBE\|command' &gt;&gt; /tmp/DUALISO/FFmpeg_ALL; done 
    if ! [ x"$(cat /tmp/DUALISO/FFmpeg_ALL)" = x ]
    then
#Start X ProRes counter
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then 
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
#ProRes time command
    res15=$(date +%s)
sleep 1
    . "$path_2"Contents/FFmpeg_ALL_01.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_02.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_03.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_ALL_04.command &amp; sleep 1
    fi
    fi
    fi
#trap
    while grep 'trap' /tmp/DUALISO/X_prores_TRAP 2&gt;/dev/null
    do
    sleep 2
    done
#ProRes time command
    res25=$(date +%s)
    if ! [ x"$res15" = x ]
    then
    dt5=$(echo "$res25 - $res15" | bc)
    dd5=$(echo "$dt5/86400" | bc)
    dt25=$(echo "$dt5-86400*$dd5" | bc)
    dh5=$(echo "$dt25/3600" | bc)
    dt35=$(echo "$dt25-3600*$dh5" | bc)
    dm5=$(echo "$dt35/60" | bc)
    ds5=$(echo "$dt35-60*$dm5" | bc) 
    fi
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd5 $dh5 $dm5 $ds5 &gt; /tmp/DUALISO/TOT_xprores 
###############################################################
#Manually selected FLATFRAMES processing
    if [ -f /tmp/DUALISO/FLATFRAMES ]
    then
    mkdir -p /tmp/DUALISO/
    mkdir -p A_ORIGINALS
#Start investigating if selected both flatdark and FLATFRAMES
    if ! [ x"$(cat /tmp/DUALISO/FLATFRAMES | awk 'FNR == 2 {print $1}')" = x ]
    then
    OLDIFS=$IFS
    IFS=$'\n'
    for FILE in `echo "$(cat /tmp/DUALISO/FLATFRAMES | head -1)" 2&gt;/dev/null`; do
    $mlv_dump --dng -f 1-1 "$FILE" &amp; pid_flat=$!
#wait for jobs to finish   
    sleep 2
#kill $mlv_dump
    kill $pid_flat
    rm *_.wav
    ls *_000001.dng &gt; /tmp/DUALISO/FLAT
    done 
    IFS=$OLDIFS 
#Inspect exposure of rgb pixel. If totally dark below 1 should do otherwise some sort of light is passing through to the sensor
    dcraw -d -W -c "$(cat /tmp/DUALISO/FLAT | head -1)" | ffmpeg -f image2pipe -vcodec ppm -i pipe:0 -pix_fmt yuvj444p "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".jpeg
#use imagemagick to read pixel brightness
    convert $(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1).jpeg -colorspace hsb -resize 1x1 $(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1).txt
    numb=$(echo $(grep '%' $(cat /tmp/DUALISO/FLAT| head -1 | cut -d "." -f1).txt | cut -d "%" -f3 | tr -d ',')) 
#grab frame size and add info to the name of the file
    fres=$($mlv_dump -m -v "$(cat /tmp/DUALISO/FLATFRAMES | head -1)" | awk '/Res/ { print $2; exit }')
    if (( $(echo "$numb &lt; 1.3" |bc -l) )); then
#remove unwanted files
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".txt
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".jpeg
    rm "$(cat /tmp/DUALISO/FLAT | head -1)"
#create the flat-dark, head -1 is the darkflat, head -2 is the FLATFRAMES
    $mlv_dump -s "$(cat /tmp/DUALISO/FLATFRAMES | head -1)" -o F_lat_D_ark.MLV "$(cat /tmp/DUALISO/FLATFRAMES | tail -1)"
    $mlv_dump F_lat_D_ark.MLV -a -o ft_"$fres"_"$(cat /tmp/DUALISO/FLATFRAMES | head -1 | grep -o '[^/]*$')"
    rm F_lat_D_ark.MLV
#move original files
    mv -i "$(cat /tmp/DUALISO/FLATFRAMES | tail -1)" A_ORIGINALS
    mv -i "$(cat /tmp/DUALISO/FLATFRAMES | head -1)" A_ORIGINALS
    else
#remove unwanted files
    rm "$(cat /tmp/DUALISO/FLAT| head -1 | cut -d "." -f1)".txt
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".jpeg
    rm "$(cat /tmp/DUALISO/FLAT | head -1)"
    $mlv_dump -s "$(cat /tmp/DUALISO/FLATFRAMES | tail -1)" -o F_lat_D_ark.MLV "$(cat /tmp/DUALISO/FLATFRAMES | head -1)"
    $mlv_dump F_lat_D_ark.MLV -a -o ft_"$fres"_"$(cat /tmp/DUALISO/FLATFRAMES | tail -1 | grep -o '[^/]*$')"
    rm F_lat_D_ark.MLV
#move original files
    mv -i "$(cat /tmp/DUALISO/FLATFRAMES | tail -1)" A_ORIGINALS
    mv -i "$(cat /tmp/DUALISO/FLATFRAMES | head -1)" A_ORIGINALS
    fi 
    fi
    fi
#If only selected flatframe without darkflat
    if [ x"$(cat /tmp/DUALISO/FLATFRAMES | awk 'FNR == 2 {print $1}')" = x ]
    then
#grab frame size and add info to the name of the file
    fres=$($mlv_dump -m -v "$(cat /tmp/DUALISO/FLATFRAMES)" | awk '/Res/ { print $2; exit }')
    OLDIFS=$IFS
    IFS=$'\n'
    $mlv_dump "$(cat /tmp/DUALISO/FLATFRAMES)" -a -o ft_"$fres"_"$(cat /tmp/DUALISO/FLATFRAMES | grep -o '[^/]*$')"
    IFS=$OLDIFS 
    rm *_.wav
#move original file
    mv -i "$(cat /tmp/DUALISO/FLATFRAMES)" A_ORIGINALS
    fi
###############################################################
#Fully automated flatframe processing(if not manual flatframe processing selected)
#Will take white space
    if [ -f /tmp/DUALISO/FLATFRAME_A ]
    then
    mkdir -p /tmp/DUALISO/
    mkdir -p A_ORIGINALS
#Creation of flatframes. Check for amount of frames, size of file
    OLDIFS=$IFS
    IFS=$'\n'    
    for FILE in `ls -A1 *.MLV *.mlv | grep -v 'avg_\|ft_' 2&gt;/dev/null`; do
    if (( $(echo "$($mlv_dump -v -m "$FILE" | awk '/Processed/ { print $2;}') &lt; 400" |bc -l) )) &amp;&amp; (( $(echo "$(wc -c &lt; "$FILE") &lt; 1000000000" |bc -l) ))
    then 
    echo "$FILE" &gt;&gt; /tmp/DUALISO/FLAT
    fi
    done
#List files according to search criteria above
    for FILE in `echo "$(cat /tmp/DUALISO/FLAT)" 2&gt;/dev/null`; do
    $mlv_dump --dng -f 1-1 "$FILE" &amp; pid_flat=$!
#wait for jobs to finish   
    sleep 2
#kill $mlv_dump
    kill $pid_flat
    rm *_.wav
    ls *_000001.dng &gt; /tmp/DUALISO/FLAT
    done 
    IFS=$OLDIFS  
#Inspect exposure of rgb pixel. If too dark below 75 it,s not conisdered a flatframe
    while grep -q 'dng' /tmp/DUALISO/FLAT
    do 
    dcraw -d -W -c "$(cat /tmp/DUALISO/FLAT | head -1)" | ffmpeg -f image2pipe -vcodec ppm -i pipe:0 -pix_fmt yuvj444p "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".jpeg
#use imagemagick to read pixel brightness
    convert $(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1).jpeg -colorspace hsb -resize 1x1 $(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1).txt
    numb=$(echo $(grep '%' $(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1).txt | cut -d "%" -f3 | tr -d ',')) 
    if (( $(echo "$numb &lt; 45" |bc -l) )); then
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".txt
    else
#Send flatframe MLV to a list which met the last criteria of exposure above 45
    echo "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "_" -f1)".MLV &gt;&gt; My_flatfr
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".txt
    fi
    rm "$(cat /tmp/DUALISO/FLAT | head -1)"
    rm "$(cat /tmp/DUALISO/FLAT | head -1 | cut -d "." -f1)".jpeg
    echo "$(tail -n +2 /tmp/DUALISO/FLAT)" &gt; /tmp/DUALISO/FLAT
    done
    rm /tmp/DUALISO/FLAT
#Create the actual flatframes
    while grep 'MLV' My_flatfr
    do
#grab frame size and add info to the name of the file
    fres=$($mlv_dump -m -v "$(cat My_flatfr | head -1)" | awk '/Res/ { print $2; exit }')
    OLDIFS=$IFS
    IFS=$'\n'
    $mlv_dump "$(cat My_flatfr | head -1)" -a -o ft_"$fres"_"$(cat My_flatfr | head -1 | grep -o '[^/]*$')"
    IFS=$OLDIFS 
    rm *_.wav
#move original file
    mv -i "$(cat My_flatfr | head -1)" A_ORIGINALS
    echo "$(tail -n +2 My_darkfr)" &gt; My_flatfr
    done
    rm My_flatfr
    fi
###############################################################
#Automated darkframe processing
#Will take white space
    if [ -f /tmp/DARK ]
    then
#if full auto was chosen
    if [ -f /tmp/DUALISO/FULL_AUTO ]
    then
    if ls *.MLV 
    then
    osascript -e 'display notification "darkframe automation in progress" with title "Auto mode"'
    afplay /System/Library/Sounds/Tink.aiff   
    fi
    fi
    mkdir -p /tmp/DUALISO/
    mkdir -p A_ORIGINALS
#Creation of darkframes. Check for amount of frames, size of file
    OLDIFS=$IFS
    IFS=$'\n'    
    for FILE in `ls -A1 *.MLV *.mlv | grep -v 'avg_\|ft_' 2&gt;/dev/null`; do
    if (( $(echo "$($mlv_dump -v -m "$FILE" | awk '/Processed/ { print $2;}') &lt; 400" |bc -l) )) &amp;&amp; (( $(echo "$(wc -c &lt; "$FILE") &lt; 1000000000" |bc -l) ))
    then 
    echo "$FILE" &gt;&gt; /tmp/DUALISO/darkf.txt
    fi
    done
#List files according to search criteria above
    for FILE in `echo "$(cat /tmp/DUALISO/darkf.txt)" 2&gt;/dev/null`; do
    $mlv_dump --dng -f 1-1 "$FILE" &amp; pid_dark=$!
#wait for jobs to finish   
    sleep 2
#kill $mlv_dump
    kill $pid_dark
    rm *_.wav
    ls *_000001.dng &gt; /tmp/DUALISO/darkf.txt
    done 
    IFS=$OLDIFS  
#Inspect exposure of rgb pixel. If totally dark below 1 should do otherwise some sort of light is passing through to the sensor
    while grep -q 'dng' /tmp/DUALISO/darkf.txt
    do 
    dcraw -d -W -c "$(cat /tmp/DUALISO/darkf.txt | head -1)" | ffmpeg -f image2pipe -vcodec ppm -i pipe:0 -pix_fmt yuvj444p "$(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1)".jpeg
#use imagemagick to read pixel brightness
    convert $(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1).jpeg -colorspace hsb -resize 1x1 $(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1).txt
    numb=$(echo $(grep '%' $(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1).txt | cut -d "%" -f3 | tr -d ',')) 
    if (( $(echo "$numb &gt; 1.3" |bc -l) )); then
    rm "$(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1)".txt
    else
#Send darkframe MLV to a list which met the last criteria of exposure below 1.3
    echo "$(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "_" -f1)".MLV &gt;&gt; My_darkfr
    rm "$(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1)".txt
    fi
    rm "$(cat /tmp/DUALISO/darkf.txt | head -1)"
    rm "$(cat /tmp/DUALISO/darkf.txt | head -1 | cut -d "." -f1)".jpeg
    echo "$(tail -n +2 /tmp/DUALISO/darkf.txt)" &gt; /tmp/DUALISO/darkf.txt
    done
    rm /tmp/DUALISO/darkf.txt
#Create the actual darkframes
    while grep 'MLV' My_darkfr
    do
    $mlv_dump -o avg_"$(cat My_darkfr | head -1)" -a "$(cat My_darkfr | head -1)"
    rm *MLV.wav
    bit=$($mlv_dump -m -v "$(cat My_darkfr | head -1)" | awk '/bits_per_pixel/ { print $2; exit }')
    res=$($mlv_dump -m -v "$(cat My_darkfr | head -1)" | awk '/Res/ { print $2; exit }')
    iso=$($mlv_dump -m -v "$(cat My_darkfr | head -1)" | awk '/ISO:/ { print $2; exit }')
    fra=$($mlv_dump -m -v "$(cat My_darkfr | head -1)" | awk '/FPS/ { print $3; exit }')
    cn=$($mlv_dump -m -v "$(cat My_darkfr | head -1)" | awk '/Camera Name/ { print $4,$5,$6,$7; exit }' | cut -d "'" -f1 | tr -d ' ')
    mv avg_"$(cat My_darkfr | head -1)" avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV
    mkdir -p A_ORIGINALS/darkframe_originals
    mv "$(cat My_darkfr | head -1)" A_ORIGINALS/darkframe_originals
    echo "$(tail -n +2 My_darkfr)" &gt; My_darkfr
    done
    rm My_darkfr
#stop if selected only_DARK
    if [ -f /tmp/only_DARK ]
    then 
    exit 0
    fi
#when going for dng files only
    if ! [ -f /tmp/only_DNG ]
    then
#Create darkframe MLV files
    OLDIFS=$IFS
    IFS=$'\n'    
    for FILE in `ls -A1 *.MLV *.mlv | grep -v 'avg_\|ft_' 2&gt;/dev/null`; do
    bit=$($mlv_dump -m -v "$FILE" | awk '/bits_per_pixel/ { print $2; exit }')
    res=$($mlv_dump -m -v "$FILE" | awk '/Res/ { print $2; exit }')
    iso=$($mlv_dump -m -v "$FILE" | awk '/ISO:/ { print $2; exit }')
    fra=$($mlv_dump -m -v "$FILE" | awk '/FPS/ { print $3; exit }')
    cn=$($mlv_dump -m -v "$FILE" | awk '/Camera Name/ { print $4,$5,$6,$7; exit }' | cut -d "'" -f1 | tr -d ' ')
    if [ -f avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV ]
    then
#Check for flatframe
    if ! ls ft_*.MLV
    then
#list mlv files and send them for processing
    ls *.MLV *.mlv | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/DF_storage
#split into 4 chunks
    split -l $(( $( wc -l &lt; /tmp/DUALISO/DF_storage ) / 4 + 1 )) /tmp/DUALISO/DF_storage /tmp/DUALISO/DF_storage
    rm /tmp/DUALISO/DF_storage
#create a new folder path file
    cat /tmp/DUALISO/path_1 &gt; /tmp/DARK_FOLDER
    . "$path_2"Contents/DF_storage_01.command &amp; 
    . "$path_2"Contents/DF_storage_02.command &amp; 
    . "$path_2"Contents/DF_storage_03.command &amp; 
    . "$path_2"Contents/DF_storage_04.command &amp; 
#trap
    while [ `ls -1 /tmp/DUALISO/DF_TRAP* 2&gt;/dev/null | wc -l ` -gt 0 ];
    do
    sleep 2
    done
    rm /tmp/DARK_FOLDER
    else
#Do frame size match?
    if [ "$res" = "$fres" ]
    then
    $mlv_dump -o a_"$FILE" -s avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV -t ft_*.MLV "$FILE"
    rm *MLV.wav
    else
    $mlv_dump -o a_"$FILE" -s avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV "$FILE"
    rm *MLV.wav
    fi
    fi
    mv -i "$FILE" A_ORIGINALS
    mv -i  "$(echo "$FILE" | cut -d "." -f1)".M* A_ORIGINALS
#if no darkframes suitable check for flatframes
    else
    if [ -f ft_*.MLV ]
    then
#Do frame size match?
    if [ "$res" = "$fres" ]
    then
    $mlv_dump -o a_"$FILE" -t ft_*.MLV "$FILE"
    rm *MLV.wav
    fi
    mv -i "$FILE" A_ORIGINALS
    mv -i  "$(echo "$FILE" | cut -d "." -f1)".M*  A_ORIGINALS
    fi
    fi
    done
    mv -i avg_*.MLV A_ORIGINALS
    mv -i ft_*.MLV A_ORIGINALS
    IFS=$OLDIFS
    fi
#if skipping dng processing
    if [ -f /tmp/NO_DNG ]
    then
    rm /tmp/NO_DNG
    exit 0
    fi
    fi
###############################################################
#extra round to check if darkframe or flatframe still are present in root folder
#when going for dng files only
    if ! [ -f /tmp/only_DNG ]
    then
#Create darkframe MLV files
    OLDIFS=$IFS
    IFS=$'\n'
    for FILE in `ls -A1 *.MLV *.mlv | grep -v 'avg_\|ft_' 2&gt;/dev/null`; do
    bit=$($mlv_dump -m -v "$FILE"| awk '/bits_per_pixel/ { print $2; exit }')
    res=$($mlv_dump -m -v "$FILE" | awk '/Res/ { print $2; exit }')
    iso=$($mlv_dump -m -v "$FILE" | awk '/ISO:/ { print $2; exit }')
    fra=$($mlv_dump -m -v "$FILE" | awk '/FPS/ { print $3; exit }')
    cn=$($mlv_dump -m -v "$FILE" | awk '/Camera Name/ { print $4,$5,$6,$7; exit }' | cut -d "'" -f1 | tr -d ' ')
#grab flatframe frame size 
    fres=$($mlv_dump -m -v ft_*.MLV | awk '/Res/ { print $2; exit }')
    if [ -f avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV ]
    then
#Check for flatframe
    if ! ls ft_*.MLV
    then
    $mlv_dump -o a_"$FILE" -s avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV "$FILE"
    rm *MLV.wav
    else
#Do frame size match?
    if [ "$res" = "$fres" ]
    then
    $mlv_dump -o a_"$FILE" -s avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV -t ft_*.MLV "$FILE"
    rm *MLV.wav
    rm *_.wav
    else
    $mlv_dump -o a_"$FILE" -s avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV "$FILE"
    rm *MLV.wav
    fi
    fi
    mv -i "$FILE" A_ORIGINALS
    mv -i  "$(echo "$FILE" | cut -d "." -f1)".M* A_ORIGINALS
#if no darkframes suitable check for flatframes
    else
    if [ -f ft_*.MLV ]
    then
#Do frame size match?
    if [ "$res" = "$fres" ]
    then
    $mlv_dump -o a_"$FILE" -t ft_*.MLV "$FILE"
    rm *MLV.wav
    fi
    mv -i "$FILE" A_ORIGINALS
    mv -i $("$FILE" | cut -d "." -f1).M* A_ORIGINALS
    fi
    fi
    done
    mv -i avg_*.MLV A_ORIGINALS
    mv -i ft_*.MLV A_ORIGINALS
    IFS=$OLDIFS
    fi
###############################################################
#Create darkframe MLV files from storage folder 
    if [ -f /tmp/DARK_FOLDER ]
    then
#Create the actual darkframes if needed
    OLDIFS=$IFS
    IFS=$'\n'    
    cd "$(cat /tmp/DARK_FOLDER)"
    ls *.MLV *.mlv | grep -v 'avg_' &gt; /tmp/DUALISO/darkf.txt
    while grep 'MLV' /tmp/DUALISO/darkf.txt
    do
    mkdir -p darkfr_ORIGINALS
    $mlv_dump -o avg_"$(cat /tmp/DUALISO/darkf.txt | head -1)" -a "$(cat /tmp/DUALISO/darkf.txt | head -1)"
    rm *MLV.wav
    bit=$($mlv_dump -m -v "$(cat /tmp/DUALISO/darkf.txt | head -1)" | awk '/bits_per_pixel/ { print $2; exit }')
    res=$($mlv_dump -m -v "$(cat /tmp/DUALISO/darkf.txt | head -1)" | awk '/Res/ { print $2; exit }')
    iso=$($mlv_dump -m -v "$(cat /tmp/DUALISO/darkf.txt | head -1)" | awk '/ISO:/ { print $2; exit }')
    fra=$($mlv_dump -m -v "$(cat /tmp/DUALISO/darkf.txt | head -1)" | awk '/FPS/ { print $3; exit }')
    cn=$($mlv_dump -m -v "$(cat /tmp/DUALISO/darkf.txt | head -1)" | awk '/Camera Name/ { print $4,$5,$6,$7; exit }' | cut -d "'" -f1 | tr -d ' ')
    mv avg_"$(cat /tmp/DUALISO/darkf.txt | head -1)" avg_"$bit"bit_"$cn"_res_"$res"_iso_"$iso"_fps_"$fra".MLV
    mv "$(cat /tmp/DUALISO/darkf.txt | head -1)" darkfr_ORIGINALS
    echo "$(tail -n +2 /tmp/DUALISO/darkf.txt)" &gt; /tmp/DUALISO/darkf.txt
    done
    rm /tmp/DUALISO/darkf.txt
    IFS=$OLDIFS
#Darkframe folder storage
#go back to root folder
    cd "$(cat /tmp/DUALISO/path_1)"
#when going for dng files only
    if ! [ -f /tmp/only_DNG ]
    then 
#list mlv files
    ls *.MLV *.mlv | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/DF_storage
#split into 4 chunks
    split -l $(( $( wc -l &lt; /tmp/DUALISO/DF_storage ) / 4 + 1 )) /tmp/DUALISO/DF_storage /tmp/DUALISO/DF_storage
    rm /tmp/DUALISO/DF_storage
#do files exist or not
    if ! [ x"$(cat /tmp/DUALISO/DF_storageaa)" = x ]
    then
    . "$path_2"Contents/DF_storage_01.command &amp; 
    . "$path_2"Contents/DF_storage_02.command &amp; 
    . "$path_2"Contents/DF_storage_03.command &amp; 
    . "$path_2"Contents/DF_storage_04.command &amp; 
    fi
#trap
    while [ `ls -1 /tmp/DUALISO/DF_TRAP* 2&gt;/dev/null | wc -l ` -gt 0 ];
    do
    sleep 2
    done
    rm /tmp/DUALISO/DF_TRAP
    fi
#NO_DNG processing after creation of darkframe processing
    if [ -f /tmp/NO_DNG ]
    then
    rm /tmp/NO_DNG
    exit 0
    fi 
    fi
###############################################################
#Processing MLV files into folders with dng files
#create the mlv time command list
    ls *.MLV *.mlv | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/MLVprogress_bar
#if full auto was chosen
    if [ -f /tmp/DUALISO/FULL_AUTO ]
    then
    if ls *.MLV 
    then
    osascript -e 'display notification "MLV to dng processing" with title "Auto mode"'
    afplay /System/Library/Sounds/Tink.aiff
    fi
    fi
#Multithreading badpixel lists. Script from dfort  
    ls *.MLV *.mlv | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/badpixelMLV
#do files exist or not
    if ! [ x"$(cat /tmp/DUALISO/badpixelMLV)" = x ]
    then
#split into 4 chunks
    split -l $(( $( wc -l &lt; /tmp/DUALISO/badpixelMLV ) / 4 + 1 )) /tmp/DUALISO/badpixelMLV /tmp/DUALISO/badpixelMLV
    rm /tmp/DUALISO/badpixelMLV
    . "$path_2"Contents/badpixels_01.command &amp; 
    . "$path_2"Contents/badpixels_02.command &amp; 
    . "$path_2"Contents/badpixels_03.command &amp; 
    . "$path_2"Contents/badpixels_04.command &amp; 
#trap
    while [ `ls -1 /tmp/DUALISO/BP_TRAP* 2&gt;/dev/null | wc -l ` -gt 0 ];
    do
    sleep 2
    done
    fi
#Start MLV counter
    if ls *.MLV 
    then 
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    for FILE in `ls -A1 *.MLV *.mlv *.M0* *.M1* *.M2* *.M3* *.M4* *.M5* | grep -v 'avg_\|ft_' 2&gt;/dev/null`; do
    $mlv_dump -v "$FILE" | awk '/Frames/ { print $3; exit}' &gt;&gt; /tmp/DUALISO/MLVprogress_bar3 
    done
    open "$path_2"Contents/progress_bar.command &amp;
    fi
    fi
#mlv_dump time command
    if ! ls /tmp/DUALISO/mlv_dump_TIME
    then
    echo &gt; /tmp/DUALISO/mlv_dump_TIME
    res11=$(date +%s)
    fi
#Will take white space
    OLDIFS=$IFS
    IFS=$'\n'
    ls *.MLV *.mlv | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/MLVFILES
#reset IFS
    IFS=$OLDIFS
#specify THREADS if
    if [ -f /tmp/THREADS ]
    then
    THR=$(cat /tmp/THREADS | tr -d Threads)
    else
    THR=$(echo 4)
    fi
#safety check
    if (( $THR &gt; 4 )); then
    THR=$(echo 4)
    fi
#split into 4 chunks
    split -l $(( $( wc -l &lt; /tmp/DUALISO/MLVFILES ) / $THR + 1 )) /tmp/DUALISO/MLVFILES /tmp/DUALISO/MLVFILES
    rm /tmp/DUALISO/MLVFILES
#if processing PROXYONLY
    if ! [ -f /tmp/PROXYONLY ]
    then
    . "$path_2"Contents/mlv_dump_01.command &amp; pid1=$!
    . "$path_2"Contents/mlv_dump_02.command &amp; pid2=$!
    . "$path_2"Contents/mlv_dump_03.command &amp; pid3=$!
    . "$path_2"Contents/mlv_dump_04.command &amp; pid4=$!
    else
    . "$path_2"Contents/proxy_only_01.command &amp; pid1=$!
    . "$path_2"Contents/proxy_only_02.command &amp; pid2=$!
    . "$path_2"Contents/proxy_only_03.command &amp; pid3=$!
    . "$path_2"Contents/proxy_only_04.command &amp; pid4=$! 
    fi
#wait for jobs to end
    wait &lt; &lt;(jobs -p)
#mlv_dump time command
    res21=$(date +%s)
    if ! [ x"$res11" = x ]
    then
    dt1=$(echo "$res21 - $res11" | bc)
    dd1=$(echo "$dt1/86400" | bc)
    dt21=$(echo "$dt1-86400*$dd1" | bc)
    dh1=$(echo "$dt21/3600" | bc)
    dt31=$(echo "$dt21-3600*$dh1" | bc)
    dm1=$(echo "$dt31/60" | bc)
    ds1=$(echo "$dt31-60*$dm1" | bc)
    fi
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd1 $dh1 $dm1 $ds1 &gt; /tmp/DUALISO/TOT_mlv_dump
###############################################################
#Processing RAW files
    if ls *.RAW 
    then
#raw2dng time command
    res12=$(date +%s)
    fi
#Start RAW counter
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    ls *.RAW | grep -v 'avg_\|ft_' &gt; /tmp/DUALISO/RAWprogress_bar
    if grep -q 'RAW' /tmp/DUALISO/RAWprogress_bar
    then
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
    fi
#if full auto was chosen
    if ls /tmp/DUALISO/FULL_AUTO
    then
    if ls *.RAW 
    then
    osascript -e 'display notification "RAW to dng processing" with title "Auto mode"'
    afplay /System/Library/Sounds/Tink.aiff
    fi
    fi
#Will take white space
    OLDIFS=$IFS
    IFS=$'\n'
    for FILE in `ls -A1 *.RAW *.raw 2&gt;/dev/null`; do
    BASE=`echo "$FILE" | cut -d "." -f1`;
    mkdir "${BASE}";
    mv "${BASE}".RAW "${BASE}"
    mv "${BASE}".R* "${BASE}"
    mv "${BASE}" "${BASE}_1_$(date +%Y-%m-%d)_0001_C0000"
    cd "${BASE}_1_$(date +%Y-%m-%d)_0001_C0000"
#RAW processing
    raw2dng "$FILE" "${BASE}_1_$(date +%Y-%m-%d)_0001_C"
#grabs the white balance tag and saves it for later  
    wib=$(exiv2 -pt "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng | awk '/Exif.Image.AsShotNeutral/ { print $4,$5,$6; }')
    mv -i "${BASE}".RAW ../A_ORIGINALS ;
    if ls "${BASE}".R*
    then
    mv -i "$BASE".R* ../A_ORIGINALS ;
    fi
#tail the RAWprogress_bar list
    echo "$(tail -n +2 /tmp/DUALISO/RAWprogress_bar)" &gt; /tmp/DUALISO/RAWprogress_bar
#reset IFS
    IFS=$OLDIFS
#M #650D #700D #100D check for pixel script
    exiftool "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng -X &gt; /tmp/DUALISO/what_cam.txt -overwrite_original
    if grep 'ColorMatrix1&gt;0.6602' /tmp/DUALISO/what_cam.txt 
    then
    fs=$(exiftool "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng | awk '/Image Size/ { print $4; }')
    this_cam=$(cat /tmp/DUALISO/"this_cam")
    fs=$(cat /tmp/DUALISO/"image_size")
    mode=$(cat /tmp/DUALISO/"mode")
    fpm.sh -c "$this_cam" -m "$mode" -s "$fs" -o "$(cat /tmp/DUALISO/path_1)"/"${BASE}"_1_$(date +%Y-%m-%d)_0001_C0000/pix_fix.txt hej.RAW &amp;
#check if default scale tag needs to be added or else only camera name gets added 
    find . -maxdepth 1 -mindepth 1 -iname '*.dng' -print0 | xargs -0 exiv2 "$(cat /tmp/DUALISO/def_scal)" -M"set Exif.Image.UniqueCameraModel Ascii $this_cam"
    fi
#check if footage is slowmotion. will add specific default scale tag
    if ! grep 'ColorMatrix1&gt;0.6602' /tmp/DUALISO/what_cam.txt
    then 
    numbc=$(exiftool "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng | awk '/Frame Rate/ { print $4; }' | cut -f1 -d".")
    count=$numbc
    if [ $count -gt 47 ]
    then 
    find . -maxdepth 1 -mindepth 1 -iname '*.dng' -print0 | xargs -0 exiv2 -M"set Exif.Image.DefaultScale Rational 1/1 5/3"
    fi
    fi
#Stored cr2hdr settings
    set=$(cat /tmp/"A_cr2hdr_settings.txt" | sed -e 's/^[ \t]*//')
#Verify dualiso or else contiue to next file
    cr2hdr $set "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng | tee /tmp/DUALISO/dualiso.txt 
    if ! grep 'look like interlaced ISO' /tmp/DUALISO/dualiso.txt
    then
    rm /tmp/DUALISO/dualiso.txt
#grab fps before it,s too late
    fps=$(exiv2 -pt "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.dng | awk '/Exif.Image.FrameRate/ { print $4; }')
#cr2hdr processing
    find . -maxdepth 1 -mindepth 1 -name '*.dng' -print0 | xargs -0 -P $(sysctl -n hw.physicalcpu) -n 1 cr2hdr $set
#grabs white level
    wle=$(exiv2 -pt "${BASE}"_1_$(date +%Y-%m-%d)_0001_C000000.DNG | awk '/Exif.SubImage1.WhiteLevel/ { print $4; }')
#adds back white balance tag, frames per second and same whitelevel to prevent flicker
    find . -maxdepth 1 -mindepth 1 -name '*.DNG' -print0 | xargs -0 -P 8 -n 1 exiv2 -M"set Exif.Image.AsShotNeutral Rational $wib" -M"set Exif.SubImage1.WhiteLevel $wle" -M"set Exif.Image.FrameRate $fps"
    fi
    cd ..
    done
#only wait for the last pixel script to be baked
while :
do
size_01=$(wc -c "${BASE}"_1_$(date +%Y-%m-%d)_0001_C0000/pix_fix.txt | awk '{print $1}')
sleep 0.5
size_02=$(wc -c "${BASE}"_1_$(date +%Y-%m-%d)_0001_C0000/pix_fix.txt | awk '{print $1}')
    if [ "$size_01" = "$size_02" ] 
    then
        break
    fi
done
#raw2dng time command
    res22=$(date +%s)
    if ! [ x"$res12" = x ]
    then
    dt2=$(echo "$res22 - $res12" | bc)
    dd2=$(echo "$dt2/86400" | bc)
    dt22=$(echo "$dt2-86400*$dd2" | bc)
    dh2=$(echo "$dt22/3600" | bc)
    dt32=$(echo "$dt22-3600*$dh2" | bc)
    dm2=$(echo "$dt32/60" | bc)
    ds2=$(echo "$dt32-60*$dm2" | bc)
    fi
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd2 $dh2 $dm2 $ds2 &gt; /tmp/DUALISO/TOT_raw2dng
###############################################################
#Export to ProRes4444 and/or ProRes proxy 
    if ! [ x"$(cat /tmp/FFmpeg_settingsPR)" = x ]
    then
    ls -d *C0000 &gt; /tmp/DUALISO/FFmpeg
#Start ProRes counter
    if ! [ x"$(cat /tmp/DUALISO/FFmpeg)" = x ]
    then 
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then 
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
#ProRes time command
    res14=$(date +%s)
    . "$path_2"Contents/FFmpeg_produce_01.command &amp; sleep 1
    if [ -f /tmp/THREADS ]
    then
    THR=$(cat /tmp/THREADS | tr -d Threads)
    if (( $THR &gt; 1 ))
    then
    . "$path_2"Contents/FFmpeg_produce_02.command &amp; sleep 1
    fi
    if (( $THR &gt; 2 ))
    then
    . "$path_2"Contents/FFmpeg_produce_03.command &amp; sleep 1
    fi
    if (( $THR &gt; 3 ))
    then
    . "$path_2"Contents/FFmpeg_produce_04.command &amp; sleep 1
    fi
    else
    . "$path_2"Contents/FFmpeg_produce_02.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_produce_03.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_produce_04.command &amp; sleep 1
    fi
    fi
    fi
#check for proxy ProRes first
    if [ x"$(cat /tmp/FFmpeg_settingsPR)" = x ]
    then
    if ! [ x"$(cat /tmp/FFmpeg_settings)" = x ]
    then
    ls -d *C0000 &gt; /tmp/DUALISO/FFmpeg
#Start ProRes counter
    if ! [ x"$(cat /tmp/DUALISO/FFmpeg)" = x ]
    then 
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
#ProRes time command
    res14=$(date +%s)
    . "$path_2"Contents/FFmpeg_produce_01.command &amp; sleep 1
    if [ -f /tmp/THREADS ]
    then
    THR=$(cat /tmp/THREADS | tr -d Threads)
    if (( $THR &gt; 1 ))
    then
    . "$path_2"Contents/FFmpeg_produce_02.command &amp; sleep 1
    fi
    if (( $THR &gt; 2 ))
    then
    . "$path_2"Contents/FFmpeg_produce_03.command &amp; sleep 1
    fi
    if (( $THR &gt; 3 ))
    then
    . "$path_2"Contents/FFmpeg_produce_04.command &amp; sleep 1
    fi
    else
    . "$path_2"Contents/FFmpeg_produce_02.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_produce_03.command &amp; sleep 1
    . "$path_2"Contents/FFmpeg_produce_04.command &amp; sleep 1
    fi
    fi
    fi
    fi
#trap
    while grep 'trap' /tmp/DUALISO/prores_TRAP 2&gt;/dev/null
    do
    sleep 2
    done
#ProRes time command
    res24=$(date +%s)
    if ! [ x"$res14" = x ]
    then
    dt4=$(echo "$res24 - $res14" | bc)
    dd4=$(echo "$dt4/86400" | bc)
    dt24=$(echo "$dt4-86400*$dd4" | bc)
    dh4=$(echo "$dt24/3600" | bc)
    dt34=$(echo "$dt24-3600*$dh4" | bc)
    dm4=$(echo "$dt34/60" | bc)
    ds4=$(echo "$dt34-60*$dm4" | bc)
    fi
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd4 $dh4 $dm4 $ds4 &gt; /tmp/DUALISO/TOT_prores
###############################################################
#Start RAW counter
#HDR_PROCESSING(don´t interfere with HDRCR2 processing)
    if ! [ -f /tmp/HDRCR2 ]
    then
    if ! [ -f /tmp/DUALISO/NOCOUNT ]
    then
    ls *.CR2 &gt; /tmp/DUALISO/CR2progress_bar
    if grep -q 'CR2' /tmp/DUALISO/CR2progress_bar
    then
    rm /tmp/DUALISO/MLVprogress_bar_key
    open "$path_2"Contents/progress_bar.command &amp;
    fi
    fi
#if full auto was chosen
    if ls /tmp/DUALISO/FULL_AUTO
    then
    if ls *.CR2
    then
    osascript -e 'display notification "CR2 dualiso processing" with title "Auto mode"'
    afplay /System/Library/Sounds/Tink.aiff
    fi
    fi
    if grep 'CR2\|DNG\|dng' &lt;&lt;&lt; "$(ls *.CR2 *.DNG *.dng)"
    then 
#Create a dng file through Adobe dng converter for camera calibration tags 
    /Applications/Adobe\ DNG\ Converter.app/Contents/MacOS/Adobe\ DNG\ Converter -d /tmp/DUALISO "$(find *.CR2 | head -1)" 
    CAL=$(find *.CR2 | head -1 | cut -f1 -d".") 
#Let exiftool extract camera calibration values
    caltagA=$(exiftool /tmp/DUALISO/"$CAL".dng | awk '/Camera Calibration 1/ { print $5; exit }') 
    caltagB=$(exiftool /tmp/DUALISO/"$CAL".dng | awk '/Camera Calibration 1/ { print $13; exit }') 
    serial=$(exiftool /tmp/DUALISO/"$CAL".dng | grep -A1 'Owner Name' | awk 'FNR == 2 {print $4; exit}')
    rm /tmp/DUALISO/"$CAL".dng
#Stored cr2hdr settings
    set=$(cat /tmp/"A_cr2hdr_settings.txt" | sed -e 's/^[ \t]*//')
    set=$(cat /tmp/"A_cr2hdr_cmpr.txt" | sed -e 's/^[ \t]*//')
#Count cpu´s
    cpu=$(sysctl -n hw.physicalcpu)
#cpu boost
    if ls /tmp/cpuboost
    then
    cpu=$(sysctl -n hw.ncpu)
    fi
#run cr2hdr 4 processes in parallel
    ls *.DNG *.dng &gt; /tmp/DUALISO/NOT_list
    echo hej &gt;&gt; /tmp/DUALISO/NOT_list
#cr2hdr time command
    res13=$(date +%s)
    if grep 'DNG\|dng' &lt;&lt;&lt; "$(ls *.CR2 *.DNG *.dng)"
    then
    find . -maxdepth 1 -mindepth 1 -iname '*.DNG' -print0 | xargs -0 -P $cpu -n 1 cr2hdr $set $cmpr
    fi 
    if grep 'CR2' &lt;&lt;&lt; "$(ls *.CR2 *.DNG *.dng)"
    then
    find . -maxdepth 1 -mindepth 1 -name '*.CR2' -print0 | xargs -0 -P $cpu -n 1 cr2hdr $set $cmpr
    fi
#cr2hdr time command
    res23=$(date +%s)
    if ! [ x"$res13" = x ]
    then
    dt3=$(echo "$res23 - $res13" | bc)
    dd3=$(echo "$dt3/86400" | bc)
    dt23=$(echo "$dt3-86400*$dd3" | bc)
    dh3=$(echo "$dt23/3600" | bc)
    dt33=$(echo "$dt23-3600*$dh3" | bc)
    dm3=$(echo "$dt33/60" | bc)
    ds3=$(echo "$dt33-60*$dm3" | bc)
    fi
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd3 $dh3 $dm3 $ds3 &gt; /tmp/DUALISO/TOT_cr2hdr
#sort out the non dualiso CR2 files
    if [ x"$(ls *.DNG)" = x ] 
    then
    mkdir -p not_dualiso
    mv *.CR2 not_dualiso
    fi
    ls *.DNG  | cut -d "." -f1 &gt; /tmp/DUALISO/not_dualiso
    while read line
    do
    echo "$line*"
    done &lt; /tmp/DUALISO/not_dualiso &gt; /tmp/DUALISO/not_dualiso1
    ls $(cat /tmp/DUALISO/not_dualiso1) &gt; /tmp/DUALISO/not_dualiso
#if you find non dualiso files move them to folder
    if ! [ x"$(ls *.CR2 | grep -v "$(cat /tmp/DUALISO/not_dualiso)")" = x ] 
    then
    mkdir -p not_dualiso
    while IFS= read -r file; do mv "$file" not_dualiso; done &lt;&lt;&lt; "$(ls *.CR2 | grep -v "$(cat /tmp/DUALISO/not_dualiso)")"
    fi   
#obtaining dcraw white balance multipliers and calculating them to AsShotNeutralvalues in the DNG file (thanks Chmee)
    ls *.CR2 &gt; /tmp/DUALISO/d_iso_list
    cr2=$(ls *.CR2 | wc -l)
#if less than 4 files
    if ! [ $(ls *.CR2 | wc -l) -lt 4 ]; then 
#if working with 6 or 7 CR2 files
    if [[ "$(echo $cr2 | tr -d ' ')" == [67] ]]; then
    sed -n 1,$(($cr2/4))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_01
    sed -n $(($cr2/4+1)),$(($cr2/4*2))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*2+1)),$(($cr2/4*3))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*3+1)),$(($cr2/4*4))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*4+1)),$(($cr2/4*5))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*5+1)),$(($cr2/4*6))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_04
    sed -n $(($cr2/4*6+1)),$(($cr2/4*7))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
#Listing of DNG files
    ls *.DNG | grep -v "$(cat /tmp/DUALISO/NOT_list)" &gt; /tmp/DUALISO/d_iso_list
    cr2=$(ls *.DNG | wc -l)
    sed -n 1,$(($cr2/4))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_01
    sed -n $(($cr2/4+1)),$(($cr2/4*2))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*2+1)),$(($cr2/4*3))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*3+1)),$(($cr2/4*4))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*4+1)),$(($cr2/4*5))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*5+1)),$(($cr2/4*6))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
    sed -n $(($cr2/4*6+1)),$(($cr2/4*7))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
#Sorting of CR2 and DNG files
    ls $(cat /tmp/DUALISO/list_01) &gt; /tmp/DUALISO/list_01
    ls $(cat /tmp/DUALISO/list_02) &gt; /tmp/DUALISO/list_02
    ls $(cat /tmp/DUALISO/list_03) &gt; /tmp/DUALISO/list_03
    ls $(cat /tmp/DUALISO/list_04) &gt; /tmp/DUALISO/list_04
    else
    sed -n 1,$(($cr2/4))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_01
    sed -n $(($cr2/4+1)),$(($cr2/4*2))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*2+1)),$(($cr2/4*3))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*3+1)),$(($cr2/4*4))p /tmp/DUALISO/d_iso_list &gt; /tmp/DUALISO/list_04
    sed -n $(($cr2/4*4+1)),$(($cr2/4*5))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
#Listing of DNG files
    ls *.DNG | grep -v "$(cat /tmp/DUALISO/NOT_list)" &gt; /tmp/DUALISO/d_iso_list
    cr2=$(ls *.DNG | wc -l)
    sed -n 1,$(($cr2/4))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_01
    sed -n $(($cr2/4+1)),$(($cr2/4*2))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_02
    sed -n $(($cr2/4*2+1)),$(($cr2/4*3))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_03
    sed -n $(($cr2/4*3+1)),$(($cr2/4*4))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
    sed -n $(($cr2/4*4+1)),$(($cr2/4*5))p /tmp/DUALISO/d_iso_list &gt;&gt; /tmp/DUALISO/list_04
#Sorting of CR2 and DNG files
    ls $(cat /tmp/DUALISO/list_01) &gt; /tmp/DUALISO/list_01
    ls $(cat /tmp/DUALISO/list_02) &gt; /tmp/DUALISO/list_02
    ls $(cat /tmp/DUALISO/list_03) &gt; /tmp/DUALISO/list_03
    ls $(cat /tmp/DUALISO/list_04) &gt; /tmp/DUALISO/list_04
    fi
#if less than 4 files
    else
    ls *.CR2 *.DNG | grep -v "$(cat /tmp/DUALISO/NOT_list)" &gt; /tmp/DUALISO/list_01 
    fi
###############################################################
#multithread processing
    . "$path_2"Contents/dualiso_to_DNG_A.command &amp; pid1=$! 
    . "$path_2"Contents/dualiso_to_DNG_B.command &amp; pid2=$! 
    . "$path_2"Contents/dualiso_to_DNG_C.command &amp; pid3=$! 
    while grep -q 'CR2' /tmp/DUALISO/list_01
    do
    CR2=$(grep 'CR2' /tmp/DUALISO/list_01 | awk 'FNR == 1 {print}')
    DNG=$(grep 'DNG' /tmp/DUALISO/list_01 | awk 'FNR == 1 {print}')
#Will add stored white balance settings to processed readymade dualiso DNG files
    echo "$(tail -n +3 /tmp/DUALISO/list_01)" &gt; /tmp/DUALISO/list_01
#matching camera serial or not
    serial_match=$(exiftool "$CR2" | grep -A1 'Owner Name' | awk 'FNR == 2 {print $4; exit}')
    if ! [ "$serial" = "$serial_match" ]; then
    /Applications/Adobe\ DNG\ Converter.app/Contents/MacOS/Adobe\ DNG\ Converter -d /tmp/DUALISO "$CR2" 
    CAL=$(echo "$CR2" | cut -f1 -d".") 
    caltagA=$(exiftool /tmp/DUALISO/"$CAL".dng | awk '/Camera Calibration 1/ { print $5; exit }') 
    caltagB=$(exiftool /tmp/DUALISO/"$CAL".dng | awk '/Camera Calibration 1/ { print $13; exit }')
    rm /tmp/DUALISO/"$CAL".dng
    fi
#check if the camera is an eos 100D
    model_match=$(exiftool "$CR2" | awk '/Camera Model Name/ { print $5,$6,$7,$8,$9,$10; exit }')
    echo "$model_match" &gt; /tmp/DUALISO/model_match
    if grep 'Canon EOS 100D\|SL1\|Kiss X7\|X7' /tmp/DUALISO/model_match
    then
    exiftool "-ColorMatrix1=0.6985 -0.1611 -0.0397 -0.3596 1.0749 0.3295 -0.0349 0.1136 0.6512" "-ColorMatrix2=0.6602 -0.0841 -0.0939 -0.4472 1.2458 0.2247 -0.0975 0.2039 0.6148" "$(find "$CR2" | cut -f1 -d".")".DNG -overwrite_original ;
    fi 
    CR2_00=$(dcraw -i -v "$CR2" | awk '/Camera multipliers/ { print $4; exit }')
    CR2_01=$(dcraw -i -v "$CR2" | awk '/Camera multipliers/ { print $3; exit }') 
    CR2_01b=$(echo "$CR2_00"/"$CR2_01" | bc -l | awk 'FNR == 1 {print}')
#If adobe dng converter is installed this calibration compensation will take place
    if ls /Applications/Adobe\ DNG\ Converter.app/Contents/MacOS/Adobe\ DNG\ Converter
    then
    CR2_01b=$(echo "$CR2_01b/$caltagA" | bc -l | awk 'FNR == 1 {print}')
    fi
    CR2_00b=$(dcraw -i -v "$CR2" | awk '/Camera multipliers/ { print $6; exit }')
    CR2_02=$(dcraw -i -v "$CR2" | awk '/Camera multipliers/ { print $5; exit }') 
    CR2_02b=$(echo "$CR2_00b"/"$CR2_02" | bc -l | awk 'FNR == 1 {print}')
#If adobe dng converter is installed this calibration compensation will take place
    if ls /Applications/Adobe\ DNG\ Converter.app/Contents/MacOS/Adobe\ DNG\ Converter
    then
    CR2_02b=$(echo "$CR2_02b/$caltagB" | bc -l | awk 'FNR == 1 {print}')
    fi
#Add neccesssary tags for white balance with exiftool. Also rearrange illuminant tags
    exiftool "-AsShotNeutral=$CR2_01b 1 $CR2_02b" "-CalibrationIlluminant1=Standard Light A" "-CalibrationIlluminant2=D65" "$DNG" -overwrite_original
    mkdir -p A_ORIGINALS
    mv -i "$CR2" A_ORIGINALS
#wait for jobs to end
    wait &lt; &lt;(jobs -p)
    done
    fi
    fi
#check if A_ORIGINALS is empty and the erase it
    if [ x"$(ls A_ORIGINALS/*)" = x ]
    then
    rm -r A_ORIGINALS
    fi
#iterate in folder tree
    echo "$(tail -n +2 /tmp/folder_paths.txt)" &gt; /tmp/folder_paths.txt
    if ! [ x"$(cat /tmp/folder_paths.txt)" = x ]
    then
    echo "$(cat /tmp/folder_paths.txt | head -1)" &gt; /tmp/DUALISO/path_1
    "$path_2"Contents/Switch_MAIN_DBG.command
    else
#The end
    sleep 1
#X to ProRes time command
    if [ x"$res15" = x ]
    then
    echo XxXx &gt; /tmp/DUALISO/TOT_xprores
    fi
#mlv_dump time command
    if [ x"$res11" = x ]
    then
    echo XxXx &gt; /tmp/DUALISO/TOT_mlv_dump
    fi
#raw2dng time command
    if [ x"$res12" = x ]
    then
    echo XxXx &gt; /tmp/DUALISO/TOT_raw2dng
    fi
#ProRes time command
    if [ x"$res14" = x ]
    then
    echo XxXx &gt; /tmp/DUALISO/TOT_prores
    fi
#cr2hdr time command check
    if [ x"$res13" = x ]
    then
    echo XxXx &gt; /tmp/DUALISO/TOT_cr2hdr
    fi
#Total time command ends here
    res2=$(date +%s)
    dt=$(echo "$res2 - $res1" | bc)
    dd=$(echo "$dt/86400" | bc)
    dt2=$(echo "$dt-86400*$dd" | bc)
    dh=$(echo "$dt2/3600" | bc)
    dt3=$(echo "$dt2-3600*$dh" | bc)
    dm=$(echo "$dt3/60" | bc)
    ds=$(echo "$dt3-60*$dm" | bc)
    sleep 1
    printf "%d Days, %02d Hrs, %02d Min, %02d Sec\n" $dd $dh $dm $ds &gt; /tmp/DUALISO/TOT_time  
    open "$path_2"Contents/progress_bar.command &amp;
    fi
 
#Thanks to Bouncyball, A1ex(cr2hdr, raw2dng, mlv_dump) g3gg0(mlv_dump) Dave Coffin(dcraw) Fabrice Bellard(FFmpeg) Phil Harvey(Exiftool) Andreas Huggel(exiv2) BWF MetaEdit(FADGI) dfort(Focus pixel script).
#Copyright Danne
</string>
					<key>CheckedForUserDefaultShell</key>
					<true/>
					<key>inputMethod</key>
					<integer>1</integer>
					<key>shell</key>
					<string>/bin/bash</string>
					<key>source</key>
					<string></string>
				</dict>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.3</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>InputUUID</key>
				<string>1D760BE8-BCB2-4602-B724-1FD0827AF649</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>B584764B-B4CF-45FC-8F51-B1D249FA132E</string>
				<key>UUID</key>
				<string>4DCE11E6-CDAB-48CF-90C8-C1846A0AA2D8</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>conversionLabel</key>
				<integer>0</integer>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>449.000000:280.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
	</array>
	<key>connectors</key>
	<dict>
		<key>2E672E08-B748-4266-B71E-788F42213192</key>
		<dict>
			<key>from</key>
			<string>1D5440C0-F1CA-47CE-B667-C9E85856710F - 1D5440C0-F1CA-47CE-B667-C9E85856710F</string>
			<key>to</key>
			<string>C9EE4BBE-A1FF-4172-A973-407B448054A0 - C9EE4BBE-A1FF-4172-A973-407B448054A0</string>
		</dict>
		<key>A2E0391F-8F4B-4F61-87AC-33A1C174DC7C</key>
		<dict>
			<key>from</key>
			<string>38172F58-AC15-47C5-B12F-FD2A20EE20D6 - 38172F58-AC15-47C5-B12F-FD2A20EE20D6</string>
			<key>to</key>
			<string>4DCE11E6-CDAB-48CF-90C8-C1846A0AA2D8 - 4DCE11E6-CDAB-48CF-90C8-C1846A0AA2D8</string>
		</dict>
		<key>A41726CD-4005-485B-954F-BA4FFB975A06</key>
		<dict>
			<key>from</key>
			<string>C9EE4BBE-A1FF-4172-A973-407B448054A0 - C9EE4BBE-A1FF-4172-A973-407B448054A0</string>
			<key>to</key>
			<string>38172F58-AC15-47C5-B12F-FD2A20EE20D6 - 38172F58-AC15-47C5-B12F-FD2A20EE20D6</string>
		</dict>
		<key>B5E24FB6-2DAB-4C9D-95E8-BDAEBB628CAC</key>
		<dict>
			<key>from</key>
			<string>1C410E4D-55FD-4C3A-9DED-99126C8F2CC7 - 1C410E4D-55FD-4C3A-9DED-99126C8F2CC7</string>
			<key>to</key>
			<string>1D5440C0-F1CA-47CE-B667-C9E85856710F - 1D5440C0-F1CA-47CE-B667-C9E85856710F</string>
		</dict>
	</dict>
	<key>workflowMetaData</key>
	<dict>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.application</string>
	</dict>
</dict>
</plist>
